---
abbrlink: 278301289
---
# 汇编语言概念

汇编语言是一种用于可编程器件的低级语言，也成为符号语言（0010 0001 0010 0000 0000 0000）

在汇编语言中，用助记符代替机器指令的操作码，用地址符号或者标号代替指令或者操作数的地址。

在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可以直接一直

如： MOV #0x1200,w0

其中MOV是助记符，#0x1200称为源操作数，w0称为目的操作数



# 汇编语言格式

![](汇编语言格式.png)



# C语言调用汇编函数

C语言调用汇编函数和C语言调用C函数的方式方式一样的

extern void AsmTest();
void StartProgram(void)
{
	AsmTest();
	while(1)
	{
	
	}
}


# 单片机是怎么样启动的

使用C语言开发的人，基本上是不会关心这个问题的，觉得一上电，单片机就直接执行main函数

但是对于单片机来说，并不是直接从Main函数开始执行的。

而是需要先初始化一些特定的对象，并且处理器处于某种特定的状态，之后才会开始执行main

而执行上面这些任务就由启动代码来完成。

启动文件中就包含了一个名为__reset的标识符

这个函数一般完成一下功能：

1.初始化堆栈

2.对一些寄存器或者处理器状态进行常规设置

3.清零未初始化的全局变量



上面是由编译器提供的启动代码的工作

如果用户自己编写了启动文件，则按照用户编写的执行相应功能。

比如：关闭中断，关闭看门狗，初始化堆栈，清零RAM，初始化时钟



GOTO指令，用于跳转到reset地址处，reset就是启动文件里面的__reset，函数结束后，会跳转到对应的函数进行运行。

![程序存储器框图](程序存储器框图.png)

## 那么reset地址是从哪里来呢？

reset地址又称为reset标识符，是由链接描述文件调用

它会指示链接器在哪里放置段，也能够给指定器件的存储器地址范围

也可以定制将用户定义的段放置在特定的地址。用户可以自行定制属于自己的启动文件。



## 链接描述文件的内容

- 处理器和启动模块
- 存储区信息
- 存储器基址
- 输入/输出段映射
- 中断向量表
- SFR 地址



## 堆栈

堆栈一般用于在一些函数调用、中断和异常处理中，用于保存发生函数调用、中断和异常发生前的现场，当函数调用、中断和异常结束后，用于恢复先前的现场。不同处理器的堆栈不一样如有的栈是满减栈，有的栈是空减栈。

堆栈空间一般可以由用户自己定义，会提供一个堆栈指针限制寄存器来检测堆栈是否发生溢出，如果溢出要么就是直接死机，要么就是发生堆栈错误异常

例如，我们的栈非常小，但是我们使用了一个递归函数，递归函数会不断把数据进行压栈操作，如果递归的层数太多或者根本就没办法跳出来，那就会栈的空间不够多，则会出现栈溢出

一般来说，链接器会分配一个相应大小的段，并初始化栈指针和堆栈指针溢出指针。这样运行的时候启动代码就可以正确地初始化堆栈



## 堆栈的设置

用MicroChip单片机为例

- 用户在链接描述文件定义：

  ![](链接描述文件定义堆栈.png)

- 用户在启动文件中设置

  mov #__SP_init,W15	;堆栈开始
  mov #__SPLIM_init,W0
  mov W0,SPLIM		;堆栈结束



# 汇编语言实战

## 编写一个启动文件Startup.s，用于实现启动代码

### 1.汇编代码的声明

.include	"..\include\p33EP128MC506.inc"

### 2.代码段定义

.section	.start_section,code

### 3.函数全局调用声明

    .global	__reset
    .global	_StartProgram
### 4.定义函数符号

__reset:

### 5.关闭中断

![中断寄存器](中断禁止寄存器.png)

因为寄存器不能直接操作（其实C语言也不能直接操作，在内部实际上都是有一个临时变量干预）

- 需要先把SR放在一个寄存器中,用C语言表示就是 w0 = SR

mov	    SR,w0

将一个立即数放到w1中，用C语言就是 w1 = 0x00e0

mov	    #0x00e0,w1

- 因为改变的是SR中bit 7-5 进行更改，所以我们可以使用或运算

  ![](IOR介绍.png)
  

ior	    w0,w1,w0 

- 最后把w0 的值赋给SR

mov	    w0,SR

### 6.关闭看门狗

![关闭看门狗](看门狗禁止寄存器.png)

   需要将bit5进行清0，使用与操作即可

  mov	    RCON,w0
  mov	    #0xffdf,w1
  and	    w0,w1,w0
  mov	    w0,RCON

### 7.做一个简单的延时

用C语言做延时，主要是用循环来进行循环操作，而汇编没有for/while

所以实现的思路为：外部循环 + 内部循环

假设我们的循环是

for(i = 0;i < 3;i++)

{	

​	for(j = 0;j < 4;j++)

​	{

​		nop（）；//空指令

​	}

}

汇编也能这么干：

mov	    #3,w1
clr	    w0
dec	    w0,w0
bra	    NZ,$-2
dec	    w1,w1
bra	    NZ,$-8

### 8.堆栈的设置

主要是设置好堆栈限制寄存器以及将栈指针指向正确的位置，我们堆栈指针使用的是W15
mov	    #__SP_init,w15  ;堆栈的开始
mov	    #__SPLIM_init,w0
mov	    w0,SPLIM ;堆栈限制寄存器

### 9.时钟初始化

时钟频率想要多少，只需要通过分频和倍频计算出来即可。

![](时钟的设置.png)

mov	    #0x0000,w0
mov	    w0,CLKDIV
mov	    #0x0024,w0
mov	    w0,OSCTUN
mov	    #0x0040,w0
mov	    w0,PLLFBD ;得到的系统时钟为120MHz

### 10.数据RAM清0

实现思路：把地址里面的数据清0\

C语言版本

int i = 0;

int arr[4];

for(i = 0;i < 3;i++)

{	

​	arr[i] = 0x00;

}

汇编版本：我们需要将0x1000 - 0x5000的地址清空

mov	    #0x1000,w0
mov	    #0x5000,w1
clr	    [w0++]
xor	    w0,w1,w2
bra	    NZ,$-4

### 11.跳转主程序

直接使用goto指令跳转

goto    _StartProgram

而_StartProgram对应C语言的的函数名则为 StartProgram()

### 完整代码

``` bash
/*--------------------汇编代码引用声明----------------------------------*/
    .include	"..\include\p33EP128MC506.inc"
/*-------------------代码段定义---------------*/
    .section	.start_section,code
/*------------------函数全局调用声明------------------*/
    .global	__reset
    .global	_StartProgram
/*------------------函数标号------------------------------------------------------*/    
__reset:
    /*-------------------关闭中断----------------------------*/
    mov	    SR,w0
    mov	    #0x00e0,w1
    ior	    w0,w1,w0 
    mov	    w0,SR
    /*-------------------关闭看门狗--------------------------*/
    mov	    RCON,w0
    mov	    #0xffdf,w1
    and	    w0,w1,w0
    mov	    w0,RCON
    /*-------------------实现一个简单的延时，大约50ms-------------------*/
    mov	    #3,w1
    clr	    w0
    dec	    w0,w0
    bra	    NZ,$-2
    dec	    w1,w1
    bra	    NZ,$-8
    /*-------------------堆栈的设置--------------------------*/
    mov	    #__SP_init,w15  ;堆栈的开始
    mov	    #__SPLIM_init,w0
    mov	    w0,SPLIM ;堆栈限制寄存器
    /*-------------------时钟的初始化--------------------------*/
    mov	    #0x0000,w0
    mov	    w0,CLKDIV
    mov	    #0x0024,w0
    mov	    w0,OSCTUN
    mov	    #0x0040,w0
    mov	    w0,PLLFBD ;得到的系统时钟为120MHz
    /*-------------------数据RAM的清零--------------------------*/
    mov	    #0x1000,w0
    mov	    #0x5000,w1
    clr	    [w0++]
    xor	    w0,w1,w2
    bra	    NZ,$-4
    
    /*-------------------跳转主程序--------------------------*/
    goto    _StartProgram
    .end
```





